<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CrashRpt: About Exceptions and Exception Handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="style.css" rel="stylesheet" type="text/css">
<link rel="icon" href="../favicon.ico" type="image/x-icon" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
</head>
<body onload='searchBox.OnSelectItem(0);'>

<div style="padding:10px">
<table border="0" bgcolor="#FFFFFF" cellspacing="5" width="100%">
 <tr>
  <td width="24px" rowspan="2"><img src="../logo.png" alt="Logo" /></td>
  <td><font family="Arial" size="+2">crashrpt</font></td>
  <td rowspan="2" align="right"></td>
 </tr>
 <tr>
  <td colspan="2"><span style="font-size:0.9em"><i>A crash reporting system for Windows applications</i></a></td>
 </tr>
</table>
</div>


<!-- Generated by Doxygen 1.5.9 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Contents</span></a></li>
      <li><a href="modules.html"><span>API&nbsp;Reference</span></a></li>
      <li><a href="files.html"><span>File&nbsp;Reference</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">CrashRpt Documentation</a>&nbsp;&raquo&nbsp;<a class="el" href="other_topics.html">Other Topics</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="exception_handling">About Exceptions and Exception Handling </a></h1>Reading this page is not necessary for using CrashRpt. However read this page if you need extended knowledge of exception handling.<p>
This page describes techniques of handling exceptions in Visual C++ programs under Windows. CrashRpt uses the techniques described below internally.<p>
The page covers the following topics:<p>
<ul>
<li><a class="el" href="exception_handling.html#about_exceptions">About Exceptions</a></li><li><a class="el" href="exception_handling.html#structured_exc">Structured Exception Handling</a></li><li><a class="el" href="exception_handling.html#vectored_exc">Vectored Exception Handling</a></li><li><a class="el" href="exception_handling.html#crt_errors">CRT Error Handling</a></li><li><a class="el" href="exception_handling.html#cpp_signals">C++ Signal Handling</a></li><li><a class="el" href="exception_handling.html#getting_exception_context">Retrieving Exception Information</a></li><li><a class="el" href="exception_handling.html#cxx_compiler_flags">Visual C++ Compiler Flags</a></li><li><a class="el" href="exception_handling.html#crt_version_and_dll">Exception Handling and CRT Linkage</a></li><li><a class="el" href="exception_handling.html#exception_handling_reference">Reference</a></li></ul>
<h2><a class="anchor" name="about_exceptions">
About Exceptions</a></h2>
An exception or a critical error typically means that a program stops working normally and needs to stop its execution.<p>
For example, an exception may occur because of the following:<p>
<ul>
<li>program accesses an invalid memory address (such as NULL pointer)</li><li>stack is overflown due to infinite recursion</li><li>large block of data is written to a small buffer</li><li>a pure virtual method of a C++ class is called</li><li>memory buffer can't be allocated (out of memory)</li><li>invalid parameter is passed to a C++ system function</li><li>C run-time libraries detect an error and request program termination</li></ul>
<p>
There are two kinds of exceptions that have different nature: SEH exceptions (Structured Exception Handling, SEH) and typed C++ exceptions.<p>
SEH exceptions were designed for C language, but they can be used in C++, too. They are handled using __try{}__except(){} construction. SEH exceptions are Visual C++ compiler-specific. You shouldn't use structured exception handling if you write portable code.<p>
C++ typed exceptions are handled using try{}catch{} construction. Example (taken from <a href="http://www.cplusplus.com/doc/tutorial/exceptions/">http://www.cplusplus.com/doc/tutorial/exceptions/</a>):<p>
<div class="fragment"><pre class="fragment"><span class="comment">// exceptions</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using namespace </span>std;

<span class="keywordtype">int</span> main () {
  <span class="keywordflow">try</span>
  {
    <span class="keywordflow">throw</span> 20;
  }
  <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> e)
  {
    cout &lt;&lt; <span class="stringliteral">"An exception occurred. Exception Nr. "</span> &lt;&lt; e &lt;&lt; endl;
  }
  <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" name="structured_exc">
Structured Exception Handling</a></h2>
When a SEH exception occurs, you typically see a pop-up window (Dr.Watson) that offers to send error report to Microsoft.<p>
You can generate a SEH exception yourself using <b>RaiseException()</b> function.<p>
You can catch a SEH exception in your code using __try{}__except(Expression){} construction. The <b>main()</b> function of your program is guarded with such construction, so by default all unhandled SEH exceptions are caught and Dr.Watson is invoked.<p>
Example:<p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span>* p = NULL;   <span class="comment">// pointer to NULL</span>
  __try
  {
    <span class="comment">// Guarded code</span>

    *p = 13; <span class="comment">// causes an access violation exception;</span>
  }
  __except(EXCEPTION_EXECUTE_HANDLER) <span class="comment">// Here is exception filter expression</span>
  {  
    <span class="comment">// Here is exception handler</span>
 
    <span class="comment">// Terminate program</span>
    ExitProcess(1);
  }
</pre></div><p>
Each SEH exception has an associated exception code. You can extract the exception code inside of __except statement using <b>GetExceptionCode()</b> intrinsic function. You can extract exception information inside of __except statement using <b>GetExceptionInformation()</b> intrinsic function. To use these intrinsic functions you usually create your custom exception filter as shown in the example below.<p>
The following example shows how to use a SEH exception filter.<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> seh_filter(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> code, <span class="keyword">struct</span> _EXCEPTION_POINTERS* ep)
{
  <span class="comment">// Generate error report</span>

  <span class="comment">// Execute exception handler</span>
  <span class="keywordflow">return</span> EXCEPTION_EXECUTE_HANDLER;
}

<span class="keywordtype">void</span> main()
{
  __try
  {
    <span class="comment">// .. some buggy code here</span>
  }
  __except(seh_filter(GetExceptionCode(), GetExceptionInformation()))
  {    
    <span class="comment">// Terminate program</span>
    ExitProcess(1);
  }
}
</pre></div><p>
The __try{}__except(){} construction is mostly C oriented. However, you can redirect a SEH exception to a C++ typed exception and handle it as you do with C++ typed exceptions. This can be done using the <b>_set_se_translator()</b> function provided by C++ runtime libraries (CRT).<p>
Example taken from MSDN:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// crt_settrans.cpp</span>
<span class="comment">// compile with: /EHa</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;windows.h&gt;</span>
<span class="preprocessor">#include &lt;eh.h&gt;</span>

<span class="keywordtype">void</span> SEFunc();
<span class="keywordtype">void</span> trans_func( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, EXCEPTION_POINTERS* );

<span class="keyword">class </span>SE_Exception
{
<span class="keyword">private</span>:
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nSE;
<span class="keyword">public</span>:
    SE_Exception() {}
    SE_Exception( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n ) : nSE( n ) {}
    ~SE_Exception() {}
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getSeNumber() { <span class="keywordflow">return</span> nSE; }
};
<span class="keywordtype">int</span> main( <span class="keywordtype">void</span> )
{
    <span class="keywordflow">try</span>
    {
        _set_se_translator( trans_func );
        SEFunc();
    }
    <span class="keywordflow">catch</span>( SE_Exception e )
    {
        printf( <span class="stringliteral">"Caught a __try exception with SE_Exception.\n"</span> );
    }
}
<span class="keywordtype">void</span> SEFunc()
{
    __try
    {
        <span class="keywordtype">int</span> x, y=0;
        x = 5 / y;
    }
    __finally
    {
        printf( <span class="stringliteral">"In finally\n"</span> );
    }
}
<span class="keywordtype">void</span> trans_func( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> u, EXCEPTION_POINTERS* pExp )
{
    printf( <span class="stringliteral">"In trans_func.\n"</span> );
    <span class="keywordflow">throw</span> SE_Exception();
}
</pre></div><p>
The disadvantage of the __try{}__catch(Expression){} construction is that you may forget to guard a potentially incorrect code that may cause an exception that won't be handled by your program. However, such an unhandled SEH exception can be caught using the top-level unhandled exception filter set with the <b>SetUnhandledExceptionFilter()</b> function.<p>
The exception information (CPU state before the exception occurred) is passed to the exception handler through <b>EXCEPTION_POINTERS</b> structure.<p>
Example:<p>
<div class="fragment"><pre class="fragment">LONG WINAPI MyUnhandledExceptionFilter(PEXCEPTION_POINTERS pExceptionPtrs)
{
  <span class="comment">// Do something, for example generate error report</span>

  <span class="comment">//..</span>

  <span class="comment">// Execute default exception handler next</span>
  <span class="keywordflow">return</span> EXCEPTION_EXECUTE_HANDLER; 
}

<span class="keywordtype">void</span> main()
{ 
  SetUnhandledExceptionFilter(MyUnhandledExceptionFilter);

  <span class="comment">// .. some unsafe code here </span>
}
</pre></div><p>
The top-level SEH exception handler works for all threads of the caller process, so its enough to call it once in the beginning of your <b>main()</b> function.<p>
The top-level SEH exception handler is called in context of the thread where exception have occurred. This can affect the exception handler's ability to recover from certain exceptions, such as an invalid stack.<p>
If your exception handler function is located inside of a DLL, be careful when using the <b>SetUnhandledExceptionFilter()</b> function. If your DLL is unloaded at the moment of crash, the behavior may be unpredictable.<h2><a class="anchor" name="vectored_exc">
Vectored Exception Handling</a></h2>
Vectored exception handling (VEH) is an extension to structured exception handling. It was introduced in Windows XP.<p>
To add a vectored exception handler, you can use the <b>AddVectoredExceptionHandler()</b> function. The disadvantage is that VEH is available in WinXP and later, so the presence of <b>AddVectoredExceptionHandler()</b> function should be checked at run-time.<p>
To remove the previously installed handler, use the <b>RemoveVectoredExceptionHandler()</b> function.<p>
VEH allows to watch or handle <em>all</em> exceptions for the application. To preserve backward compatibility, when a SEH exception occurs in some part of the program, the system calls installed VEH handlers in turn, after that it searches for the usual SEH handlers.<p>
An advantage of VEH is an ability to chain exception handlers, so if somebody installs vectored exception handler above yours, you still can intercept the exception.<p>
Vectored exception handling is suitable when you need to monitor _ALL_ exceptions, like a debugger does. But the problem is you have to decide which exception to handle and which to skip. In program's code, some exceptions may be intentionally guarded by __try{}__except(){} construction, and handling such exceptions in VEH and not passing it to frame-based SEH handler, you may introduce bugs into application logics.<p>
VEH is currently not used by CrashRpt. <b>SetUnhandledExceptionFilter()</b> is more suitable, because it is the top-level SEH handler. If nobody handles the exception, top-level SEH handler is called and you don't need to decide if you should skip the exception or not.<h2><a class="anchor" name="crt_errors">
CRT Error Handling</a></h2>
In addition to SEH exceptions and C++ typed exceptions, C runtime libraries (CRT) provide their own error handling mechanism that should be taken into account in your program.<p>
When CRT encounters an unhandled C++ typed exception, it calls <b>terminate()</b> function. To intercept such calls and take an appropriate action you should set error handler using <b>set_terminate()</b> function.<p>
Example:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> my_terminate_handler()
{
  <span class="comment">// Abnormal program termination (terminate() function was called)</span>

  <span class="comment">// Do something here</span>

  <span class="comment">// Finally, terminate program</span>
  exit(1); 
}

<span class="keywordtype">void</span> main()
{
  set_terminate(my_terminate_handler);

  terminate();
}
</pre></div><p>
There is <b>unexpected()</b> function that is not used with the current implementation of Visual C++ exception handling. However, consider using the <b>set_unexpected()</b> function to set handler for the <b>unexpected()</b> function, too.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>In a multi-threaded environment, unexpected and terminate functions are maintained separately for each thread. Each new thread needs to install its own unexpected and terminate function. Thus, each thread is in charge of its own unexpected and terminate handling.</dd></dl>
Use the <b>_set_purecall_handler()</b> function to handle pure virtual function calls. This function can be used in VC++ .NET 2003 and later. This function works for all threads of the caller process.<p>
Example (taken from MSDN):<p>
<div class="fragment"><pre class="fragment"><span class="comment">// _set_purecall_handler.cpp</span>
<span class="comment">// compile with: /W1</span>
<span class="preprocessor">#include &lt;tchar.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="keyword">class </span>CDerived;
<span class="keyword">class </span>CBase
{
<span class="keyword">public</span>:
   CBase(CDerived *derived): m_pDerived(derived) {};
   ~CBase();
   <span class="keyword">virtual</span> <span class="keywordtype">void</span> function(<span class="keywordtype">void</span>) = 0;

   CDerived * m_pDerived;
};

<span class="keyword">class </span>CDerived : <span class="keyword">public</span> CBase
{
<span class="keyword">public</span>:
   CDerived() : CBase(this) {};   <span class="comment">// C4355</span>
   <span class="keyword">virtual</span> <span class="keywordtype">void</span> function(<span class="keywordtype">void</span>) {};
};

CBase::~CBase()
{
   m_pDerived -&gt; function();
}

<span class="keywordtype">void</span> myPurecallHandler(<span class="keywordtype">void</span>)
{
   printf(<span class="stringliteral">"In _purecall_handler."</span>);
   exit(0);
}

<span class="keywordtype">int</span> _tmain(<span class="keywordtype">int</span> argc, _TCHAR* argv[])
{
   _set_purecall_handler(myPurecallHandler);
   CDerived myDerived;
}
</pre></div><p>
Use the <b>_set_new_handler()</b> function to handle memory allocation faults. This function can be used in VC++ .NET 2003 and later. This function works for all threads of the caller process. Consider also using the <b>_set_new_mode()</b> function to define error behaviour for the <b>malloc()</b> function.<p>
Example (taken from MSDN):<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;new.h&gt;</span>
<span class="keywordtype">int</span> handle_program_memory_depletion( <span class="keywordtype">size_t</span> )
{
   <span class="comment">// Your code</span>
}
<span class="keywordtype">int</span> main( <span class="keywordtype">void</span> )
{
   _set_new_handler( handle_program_memory_depletion );
   <span class="keywordtype">int</span> *pi = <span class="keyword">new</span> <span class="keywordtype">int</span>[BIG_NUMBER];
}
</pre></div><p>
In Visual C++ .NET 2003, you can use <b>_set_security_error_handler()</b> function to handle buffer overrun errors. This function is declared deprecated and is removed from CRT in later versions of VC++.<p>
Use the <b>_set_invalid_parameter_handler()</b> function to handle situations when CRT detects an invalid argument in a system function call. This function can be used in VC++ 2005 and later. This function works for all threads of the caller process.<p>
Example (taken from MSDN):<p>
<div class="fragment"><pre class="fragment"><span class="comment">// crt_set_invalid_parameter_handler.c</span>
<span class="comment">// compile with: /Zi /MTd</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;crtdbg.h&gt;</span>  <span class="comment">// For _CrtSetReportMode</span>

<span class="keywordtype">void</span> myInvalidParameterHandler(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* expression,
   <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* function, 
   <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* file, 
   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> line, 
   uintptr_t pReserved)
{
   wprintf(L<span class="stringliteral">"Invalid parameter detected in function %s."</span>
            L<span class="stringliteral">" File: %s Line: %d\n"</span>, function, file, line);
   wprintf(L<span class="stringliteral">"Expression: %s\n"</span>, expression);
}


<span class="keywordtype">int</span> main( )
{
   <span class="keywordtype">char</span>* formatString;

   _invalid_parameter_handler oldHandler, newHandler;
   newHandler = myInvalidParameterHandler;
   oldHandler = _set_invalid_parameter_handler(newHandler);

   <span class="comment">// Disable the message box for assertions.</span>
   _CrtSetReportMode(_CRT_ASSERT, 0);

   <span class="comment">// Call printf_s with invalid parameters.</span>

   formatString = NULL;
   printf(formatString);
}
</pre></div><h2><a class="anchor" name="cpp_signals">
C++ Signal Handling</a></h2>
C++ provides program interruption mechanism called signals. You can handle signals with the <b>signal()</b> function.<p>
In Visual C++, there are 6 types of signals:<p>
<ul>
<li><code>SIGABRT</code> Abnormal termination</li><li><code>SIGFPE</code> Floating-point error</li><li><code>SIGILL</code> Illegal instruction</li><li><code>SIGINT</code> CTRL+C signal</li><li><code>SIGSEGV</code> Illegal storage access</li><li><code>SIGTERM</code> Termination request</li></ul>
<p>
MSDN says that the <code>SIGILL</code>, <code>SIGSEGV</code>, and <code>SIGTERM</code> signals are not generated under Windows NT and included for ANSI compatiblity. However, if you set the SIGSEGV signal handler in the main thread, it is called by CRT instead of SEH exception handler set with <b>SetUnhandledExceptionFilter()</b> function and the global variable <b>_pxcptinfoptrs</b> contains a pointer to the exception information. In other threads the exception filter set with <b>SetUnhandledExceptionFilter()</b> function is called instead of SIGSEGV handler.<p>
The <b>_pxcptinfoptrs</b> can be also used in the SIGFPE handler. In all other signal handlers it seems to be NULL.<p>
The SIGFPE signal handler is called by CRT when a floating point error occurs, such as division by zero. However, by default floating point exceptions are not generated, instead NaN or infinity numbers are generated as the result of a floating point operation. Use the <b>_controlfp_s()</b> function to enable the floating point exception generation.<p>
You can generate all 6 signals manually using <b>raise()</b> function.<p>
Example:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> sigabrt_handler(<span class="keywordtype">int</span>)
{
  <span class="comment">// Caught SIGABRT C++ signal</span>

  <span class="comment">// Terminate program</span>
  exit(1);
}

<span class="keywordtype">void</span> main()
{
  signal(SIGABRT, sigabrt_handler);
     
  <span class="comment">// Cause abort</span>
  abort();       
}                
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Although it is not well documented in MSDN, it seems that you should install SIGFPE, SIGILL and SIGSEGV signal handlers for each new thread in your program. The SIGABRT, SIGINT and SIGTERM signal handlers seems to work for all threads of the caller process, so you should install them once in your <b>main()</b> function.</dd></dl>
<h2><a class="anchor" name="getting_exception_context">
Retrieving Exception Information</a></h2>
When an exception occurs you typically want to get the CPU state to determine the place in your code that caused the problem. You use the information to debug the problem. The way you retrieve the exception information differs depending on the exception handler you use.<p>
In the SEH exception handler set with the <b>SetUnhandledExceptionFilter()</b> function, the exception information is retrieved from <b>EXCEPTION_POINTERS</b> structure passed as function parameter.<p>
In __try{}__catch(Expression){} construction you retrieve exception information using <b>GetExceptionInformation()</b> intrinsic function and pass it to the SEH exception filter function as parameter.<p>
In the SIGFPE and SIGSEGV signal handlers you can retrieve the exception information from the <b>_pxcptinfoptrs</b> global CRT variable that is declared in &lt;signal.h&gt;. This variable is not documented well in MSDN.<p>
In other signal handlers and in CRT error handlers you have no ability to easily extract the exception information. I found a workaround used in CRT code (see CRT 8.0 source files, invarg.c, line 104).<p>
The following code shows how to get current CPU state used as exception information.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#if _MSC_VER&gt;=1300</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;rtcapi.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifndef _AddressOfReturnAddress</span>
<span class="preprocessor"></span>
<span class="comment">// Taken from: http://msdn.microsoft.com/en-us/library/s975zw7k(VS.71).aspx</span>
<span class="preprocessor">#ifdef __cplusplus</span>
<span class="preprocessor"></span><span class="preprocessor">#define EXTERNC extern "C"</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#define EXTERNC</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">// _ReturnAddress and _AddressOfReturnAddress should be prototyped before use </span>
EXTERNC <span class="keywordtype">void</span> * _AddressOfReturnAddress(<span class="keywordtype">void</span>);
EXTERNC <span class="keywordtype">void</span> * _ReturnAddress(<span class="keywordtype">void</span>);

<span class="preprocessor">#endif </span>
<span class="preprocessor"></span>
<span class="comment">// The following function retrieves exception info</span>

<span class="keywordtype">void</span> GetExceptionPointers(DWORD dwExceptionCode, 
  EXCEPTION_POINTERS** ppExceptionPointers)
{
  <span class="comment">// The following code was taken from VC++ 8.0 CRT (invarg.c: line 104)</span>
  
  EXCEPTION_RECORD ExceptionRecord;
  CONTEXT ContextRecord;
  memset(&amp;ContextRecord, 0, <span class="keyword">sizeof</span>(CONTEXT));
  
<span class="preprocessor">#ifdef _X86_</span>
<span class="preprocessor"></span>
  __asm {
      mov dword ptr [ContextRecord.Eax], eax
      mov dword ptr [ContextRecord.Ecx], ecx
      mov dword ptr [ContextRecord.Edx], edx
      mov dword ptr [ContextRecord.Ebx], ebx
      mov dword ptr [ContextRecord.Esi], esi
      mov dword ptr [ContextRecord.Edi], edi
      mov word ptr [ContextRecord.SegSs], ss
      mov word ptr [ContextRecord.SegCs], cs
      mov word ptr [ContextRecord.SegDs], ds
      mov word ptr [ContextRecord.SegEs], es
      mov word ptr [ContextRecord.SegFs], fs
      mov word ptr [ContextRecord.SegGs], gs
      pushfd
      pop [ContextRecord.EFlags]
  }

  ContextRecord.ContextFlags = CONTEXT_CONTROL;
<span class="preprocessor">#pragma warning(push)</span>
<span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable:4311)</span>
<span class="preprocessor"></span>  ContextRecord.Eip = (ULONG)_ReturnAddress();
  ContextRecord.Esp = (ULONG)_AddressOfReturnAddress();
<span class="preprocessor">#pragma warning(pop)</span>
<span class="preprocessor"></span>  ContextRecord.Ebp = *((ULONG *)_AddressOfReturnAddress()-1);


<span class="preprocessor">#elif defined (_IA64_) || defined (_AMD64_)</span>
<span class="preprocessor"></span>
  <span class="comment">/* Need to fill up the Context in IA64 and AMD64. */</span>
  RtlCaptureContext(&amp;ContextRecord);

<span class="preprocessor">#else  </span><span class="comment">/* defined (_IA64_) || defined (_AMD64_) */</span>

  ZeroMemory(&amp;ContextRecord, <span class="keyword">sizeof</span>(ContextRecord));

<span class="preprocessor">#endif  </span><span class="comment">/* defined (_IA64_) || defined (_AMD64_) */</span>

  ZeroMemory(&amp;ExceptionRecord, <span class="keyword">sizeof</span>(EXCEPTION_RECORD));

  ExceptionRecord.ExceptionCode = dwExceptionCode;
  ExceptionRecord.ExceptionAddress = _ReturnAddress();

  
  EXCEPTION_RECORD* pExceptionRecord = <span class="keyword">new</span> EXCEPTION_RECORD;
  memcpy(pExceptionRecord, &amp;ExceptionRecord, <span class="keyword">sizeof</span>(EXCEPTION_RECORD));
  CONTEXT* pContextRecord = <span class="keyword">new</span> CONTEXT;
  memcpy(pContextRecord, &amp;ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));

  *ppExceptionPointers = <span class="keyword">new</span> EXCEPTION_POINTERS;
  (*ppExceptionPointers)-&gt;ExceptionRecord = pExceptionRecord;
  (*ppExceptionPointers)-&gt;ContextRecord = pContextRecord;  
}
</pre></div><h2><a class="anchor" name="cxx_compiler_flags">
Visual C++ Compiler Flags</a></h2>
There are several Visual C++ compiler switches that are related to exception handling. You can find the switches if open project Properties-&gt;Configuration Properties-&gt;C/C++-&gt;Code Generation.<p>
<b>Exception Handling Model</b><p>
You set an exception handling model for your Visual C++ compiler with <b>/EHs</b> (or <b>EHsc</b>) to specify synchronous exception handling model or <b>/EHa</b> to specify asynchronous exception handling model. See the <em>/EH (Exception Handling Model)</em> in the Reference section below for more information.<p>
<b>Floating Point Exceptions</b><p>
You enable floating point exceptions using <b>/fp:except</b> compiler flag. For more information, see the <em> /fp (Specify Floating Point Behavior)</em> in the Reference section below.<p>
<b>Buffer Security Checks</b><p>
By default you have the <b>/GS</b> (Buffer Security Check) compiler flag enabled that force compiler to inject code that would check buffer overruns. A buffer overrun is a situation when a large block of data is written to a small buffer. When a buffer overrun is detected, CRT calls internal security handler that invokes Watson directly. For more information, see the <em> /GS (Buffer Security Check)</em> in the Reference section below.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd></dd></dl>
In Visual C++ .NET (CRT 7.1) you can use <b>_set_security_error_handler</b> function that CRT calls when buffer overrun is detected. However, this function is deprecated in the later versions of CRT.<p>
Since CRT 8.0 you can't intercept security errors in your code. When buffer overrun is detected, CRT invokes Watson directly instead of calling unhandled exception filter. This is done because of security reasons and Microsoft doesn't plan to change this behavior.<p>
For additional info please see these links:<ul>
<li><a href="https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=101337">https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=101337</a></li><li><a href="http://blog.kalmbachnet.de/?postid=75">http://blog.kalmbachnet.de/?postid=75</a></li></ul>
<h2><a class="anchor" name="crt_version_and_dll">
Exception Handling and CRT Linkage</a></h2>
Each module (EXE, DLL) in your application is linked to CRT (C run-time libraries). You may link CRT as multi-threaded static library or as multi-threaded dynamic link library. When you set CRT error handlers, such as terminate handler, unexpected handler, pure call handler, invalid parameter handler, new operator error handler or a signal handler, they will work for the CRT the caller module is linked to and won't intercept exceptions in different CRT modules (if exist), because each CRT module has its own internal state.<p>
Several project modules may share single CRT DLL. This reduces to minimum the overall size of linked CRT code. And all exceptions within that CRT DLL can be handled at once. That's why multi-threaded CRT DLL is the recommended way of CRT linkage.<p>
If you plan to use CRT as a static link library (which is not recommended to do) and want to use some crash reporting functionality, you have to build the functionality as a static library with /NODEFAULTLIB linker flag and then link this functionality to each EXE and DLL module of your application. You would also have to install the CRT error handlers for each module of your application, while the SEH exception handler would still be installed once.<p>
For additional info about C run-time libraries (CRT), see the <em>C Run-time Libraries (CRT)</em> link in the Reference section below.<p>
See also:<ul>
<li><a class="el" href="configuring_project.html#crtdll">Using CRT as Multi-Threaded DLL (/MD) in Release Configuration</a></li><li><a class="el" href="configuring_project.html#crtver">Using the Same Version of CRT for All Application Modules</a></li></ul>
<h2><a class="anchor" name="exception_handling_reference">
Reference</a></h2>
<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/x057540h%28VS.80%29.aspx">Exception Handling in Visual C++</a></li><li><a href="http://msdn.microsoft.com/en-us/library/ms680634%28VS.85%29.aspx">SetUnhandledExceptionFilter()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/ms680552%28VS.85%29.aspx">RaiseException()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/ms679357%28VS.85%29.aspx">GetExceptionInformation()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/ms679356%28VS.85%29.aspx">GetExceptionCode()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/t6fk7h29%28VS.71%29.aspx">set_terminate()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/h46t5b69%28VS.71%29.aspx">set_unexpected()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/5z4bw5h5%28VS.71%29.aspx">_set_se_translator()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/ms395801%28VS.71%29.aspx">_set_security_error_handler()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/t296ys27%28VS.71%29.aspx">_set_purecall_handler()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/a45x8asx%28VS.71%29.aspx">_set_new_handler()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/a9yf33zb%28VS.80%29.aspx">_set_invalid_parameter_handler()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/xdkz3x12%28VS.71%29.aspx">signal()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/dwwzkt4c%28VS.71%29.aspx">raise()</a></li><li><a href="http://msdn.microsoft.com/en-us/library/1deeycx5%28VS.80%29.aspx">/EH (Exception Handling Model)</a></li><li><a href="http://msdn.microsoft.com/en-us/library/e7s85ffb%28VS.80%29.aspx">/fp (Specify Floating-Point Behavior)</a></li><li><a href="http://msdn.microsoft.com/en-us/library/8dbf701c%28VS.80%29.aspx">/GS (Buffer Security Check)</a></li><li><a href="http://msdn.microsoft.com/en-us/library/abx4dbyh%28VS.80%29.aspx">C Run-time Libraries (CRT)</a></li><li><a href="http://msdn.microsoft.com/en-us/magazine/cc301714.aspx">Under the Hood: New Vectored Exception Handling in Windows XP</a></li><li><a href="http://msdn.microsoft.com/en-us/library/ms681420%28VS.85%29.aspx">Vectored Exception Handling</a></li><li><a href="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx">AddVectoredExceptionHandler Function</a></li><li><a href="http://msdn.microsoft.com/en-us/library/ms680571%28VS.85%29.aspx">RemoveVectoredExceptionHandler Function</a> </li></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Mon Apr 8 15:41:10 2013 for CrashRpt by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9</small></address>
</body>
</html>

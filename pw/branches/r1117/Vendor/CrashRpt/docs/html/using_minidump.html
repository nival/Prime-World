<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CrashRpt: Using Crash Minidump</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="style.css" rel="stylesheet" type="text/css">
<link rel="icon" href="../favicon.ico" type="image/x-icon" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
</head>
<body onload='searchBox.OnSelectItem(0);'>

<div style="padding:10px">
<table border="0" bgcolor="#FFFFFF" cellspacing="5" width="100%">
 <tr>
  <td width="24px" rowspan="2"><img src="../logo.png" alt="Logo" /></td>
  <td><font family="Arial" size="+2">crashrpt</font></td>
  <td rowspan="2" align="right"></td>
 </tr>
 <tr>
  <td colspan="2"><span style="font-size:0.9em"><i>A crash reporting system for Windows applications</i></a></td>
 </tr>
</table>
</div>


<!-- Generated by Doxygen 1.5.9 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Contents</span></a></li>
      <li><a href="modules.html"><span>API&nbsp;Reference</span></a></li>
      <li><a href="files.html"><span>File&nbsp;Reference</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">CrashRpt Documentation</a>&nbsp;&raquo&nbsp;<a class="el" href="using_error_reports.html">Using Error Reports</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="using_minidump">Using Crash Minidump </a></h1>A crash minidump file (DMP file) contains various information about the state of the application at the moment of time when it crashed.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The minidump file is created as follows. All the threads of the parent process are suspended, and a "snapshot" of the process is recorded. The snapshot includes the names and versions of all DLL-modules loaded into the process and the list of threads that work in the process. For each of those threads, call stack image is recorded. Also, the information about the version of the operating system, the number of CPUs and their brand names are written to minidump file.<p>
The minidump is usually created with the help of the DbgHelp DLL's <b>MiniDumpWriteDump()</b> function. For additional information on the <b>MiniDumpWriteDump()</b> function, please refer to MSDN.</dd></dl>
Technically, the crash minidump file may contain:<ul>
<li>general system information (OS version, CPU count, etc.);</li><li>blocks of process memory (including values of global variables, the call stack and local variables for each execution thread);</li><li>the list of loaded and unloaded modules (including their versions and timestamps).</li></ul>
<p>
Minidump size is typically about several tens of kilobytes, but the actual content of the minidump depends on the minidump type you pass as the value of the <a class="el" href="struct_c_r___i_n_s_t_a_l_l___i_n_f_o_a.html#9e09d512b1b4568028f0718dc3856ce2">CR_INSTALL_INFO::uMiniDumpType</a> field.<p>
To analyze crash minidump files generated by the CrashRpt library, you typically open those files in Visual Studio or in WinDbg. The following two sections of this page describe minidump opening instructions in details:<ul>
<li><a class="el" href="using_minidump.html#opening_minidump_in_vs">Opening Minidump in Visual Studio</a></li><li><a class="el" href="using_minidump.html#opening_minidump_in_windbg">Opening Minidump in WinDbg</a></li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>In order to recover the stack trace from the crash minidump, you need the debugging symbols (program database, PDB) generated by the compiler/linker for modules of your application. You may also need the source code of your application to be able to edit the place in the code where the crash happened.</dd></dl>
<h2><a class="anchor" name="opening_minidump_in_vs">
Opening Minidump in Visual Studio</a></h2>
In order to illustrate how to open a minidump file in Visual Studio, we will use a minidump file created for the <em>WTLDemo.exe</em> demo application which is distributed with CrashRpt distribution archive.<p>
To create such a minidump, you can follow the steps below:<p>
<ul>
<li>Compile (if you haven't yet compiled) the CrashRpt in Release configuration as described on <a class="el" href="compiling_crashrpt.html">Compiling CrashRpt</a> page.</li></ul>
<p>
<ul>
<li>Go to the <em>bin</em> directory under the top-level directory of CrashRpt distribution. You can see that Visual Studio has created several EXE and DLL binary files (<em>WTLDemo.exe</em>, <em>CrashRptXXXX.dll</em>, etc.) and PDB files for those binaries (<em>WTLDemo.pdb</em>, <em>CrashRptXXXX.pdb</em>, etc.) The XXXX is the placeholder for the actual version of CrashRpt library.</li></ul>
<p>
<ul>
<li>Save the binary files and PDB files to some folder (see also <a class="el" href="preparing_to_software_release.html">Preparing to Software Release</a> page for additional information).</li></ul>
<p>
Finally, you should have a directory structure like this:<p>
<ul>
<li>WTLDemo<ul>
<li>1.4.1<ul>
<li>WTLDemo.exe</li><li>WTLDemo.pdb</li><li>CrashRpt1401.dll</li><li>CrashRpt1401.pdb</li></ul>
</li></ul>
</li></ul>
<p>
<ul>
<li>Save the source code of the WTLDemo application to some directory (we will need it later). The source code of the WTLDemo app is located inside of <em>\demos\WTLDemo</em> subdirectory under the top-level directory of CrashRpt distribution.</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If you use SVN or another version control system for storing your code, you can just mark the revision with a tag to be able to restore the state of the code at any time.</dd></dl>
<ul>
<li>Next, go to the <em>bin</em> directory again and run the <em>WTLDemo.exe</em>. When the dialog appears, click the "Crash" button. When <em>Error Report</em> dialog appears, click the "What does this error report contains?" link. Then in the <em>Error Report Details</em> dialog, click the "Export..." button to export the error report files as a ZIP archive. Export your error report to some directory.</li></ul>
<p>
<ul>
<li>Unzip the error report archive. It contains <em>crashdump.dmp</em> file and several other files.</li></ul>
<p>
Now, when you have the <em>crashdump.dmp</em> file, you can open it in Visual Studio. In order to open crash minidump file, double-click its file name.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Alternatively, if you have several versions of Visual Studio installed (for example a commercial one and an Express edition) right-click the filename and in the context menu select <em>Open With</em> and then choose what Visual Studio version to use.</dd></dl>
A new Visual Studio window appears displaying general information on the <em>crashdump.dmp</em> (see the figure below).<p>
<div align="center">
<img src="crashdump_sln.png" alt="crashdump_sln.png">
<p><strong>Visual Studio: crashdump.dmp</strong></p></div>
 In the Visual Studio window, click the <em>Debug with Native Only</em> to load the minidump data. When the data has been loaded, you should be able to see the dialog containing information about the exception, such as exception address, module name, exception code and its textual description (see the figure below). Press the 'Break' button to continue.<p>
<div align="center">
<img src="vs_unhandled_exception.png" alt="vs_unhandled_exception.png">
<p><strong>Unhandled Exception Message</strong></p></div>
 In the <em>Output</em> window, you should be able to see the log of minidump loading progress. If you do not see the <em>Output window</em>, open menu <em>View</em> and click the <em>Output</em> menu item.<p>
<div align="center">
<img src="output_window.png" alt="output_window.png">
<p><strong>Output Window</strong></p></div>
 Now look at the <em>Modules</em> window. If you do not see such a window, open menu <em>Debug-&gt;Windows</em> and select the <em>Modules</em> menu item. Click the <em>Symbol Status</em> column header twice to sort modules by symbol load status in descending order. Now you should be able to see what symbols have beel loaded for <em>WTLDemo.exe</em> and <em>CrashRptXXXX.dll</em> modules.<p>
<div align="center">
<img src="modules.png" alt="modules.png">
<p><strong>Modules: Symbols load status for each module</strong></p></div>
 As the debug symbols seem to be loaded successfully for the main modules of the application, in the code window (see the figure below) you should be able to see the place in your source code where the exception occurred. We can see that the crash occurred in file <em>CrashRpt.cpp</em> at line 829 inside of <a class="el" href="group___crash_rpt_a_p_i.html#g71fc93e6828f68f88b80326104489720" title="Emulates a predefined crash situation.">crEmulateCrash()</a> function because of assigning a null pointer variable with the value 0. If the reason of the crash is clear, you even can edit the source code right in place to fix the problem.<p>
<div align="center">
<img src="code_line.png" alt="code_line.png">
<p><strong>Line of the code where exception occurred</strong></p></div>
 <dl class="note" compact><dt><b>Note:</b></dt><dd>If line numbers are not displayed (this is the default), open menu <em>Tools-&gt;Options...</em>, in appeared dialog's tree choose <em>Text Editor-&gt;C++</em>, and then set the check mark in the <em>Line numbers</em> field.</dd></dl>
You can see the values of local variables by moving the mouse cursor over the variable name. The value (if known) is displayed in a tooltip window. Not all variable's values can be recovered, this depends on the minidump type you use and on other factors, such as code optimizations.<p>
In order to better understand the reason of the crash, we would like to know what C++ class or function called the <a class="el" href="group___crash_rpt_a_p_i.html#g71fc93e6828f68f88b80326104489720" title="Emulates a predefined crash situation.">crEmulateCrash()</a> function and for what purpose. We can do that with the help of the <em>Call stack</em> window (see the figure below). If the Call stack window is hidden, open menu <em>Debug-&gt;Windows</em> and select the 'Call Stack' menu item.<p>
<div align="center">
<img src="call_stack.png" alt="call_stack.png">
<p><strong>Call Stack</strong></p></div>
 Each line (also called a <em>stack frame</em>) of the stack trace contains the name of module the code belongs to, the name of symbol (function or class), offset from beginning of symbol code, source file and line number. Moving down the stack, we can see that <a class="el" href="group___crash_rpt_a_p_i.html#g71fc93e6828f68f88b80326104489720" title="Emulates a predefined crash situation.">crEmulateCrash()</a> was called by the <b>CMainDlg::DoCrash()</b> class method, which, in turn was called by the <b>CMainDlg::OnOK()</b> method as the result of button click.<p>
Typically, the program has several execution threads. You can switch between threads using the <em>Threads</em> tab and browse the stack for each thread. We can see that there are two threads in the application: the main thread and the worker thread. The exception occured in the main thread, the second thread didn't crash.<p>
<div align="center">
<img src="threads.png" alt="threads.png">
<p><strong>Threads Window</strong></p></div>
 Finally, when you have finished with analyzing minidump data, close the Visual Studio window.<h2><a class="anchor" name="troubleshooting_pdb">
Troubleshooting</a></h2>
The case described above is the easiest one, because Visual Studio located all binaries, PDB files and source files automatically. But in general, there may be some problems with reading minidumps, when Visual Studio can't locate those files, or when the timestamps of those files do not match.<p>
In order to locate matching binaries, PDB files and source code files, Visual Studio uses the absolute paths embedded into the PDB file at the time of compilation and linking. So, when you do not delete/move/modify the files you used to build the solution, Visual Studio can locate them automatically. But, if you delete/move or modify those files, Visual Studio won't be able to locate them.<p>
In order to illustrate such a case, we will remove the entire <em>bin</em> and <em>\demos\WTLDemo</em> folders containing WTLDemo's source code we used for compilation, together with resulting binaries and PDB files. Then if we open the minidump file again, in the <em>Modules</em> window we will see that the symbols could not be loaded (see the figure below).<p>
<div align="center">
<img src="no_symbols_loaded.png" alt="no_symbols_loaded.png">
<p><strong>No Symbols Loaded</strong></p></div>
 Symbol status for <em>WTLDemo.exe</em> and <em>CrashRpt1401.dll</em> modules shows that there were no matching binaries found. In order to fix this, you should specify symbol search path manually. In the minidump window, click the <em>Set symbol paths</em> and enter the path to the directory where your PDB files are located (see the figure below for example).<p>
<div align="center">
<img src="symbols_load_paths.png" alt="symbols_load_paths.png">
<p><strong>Where to load symbols from</strong></p></div>
 Now reload the minidump. You can see that the stack trace is now recovered correctly. But there is still one problem - the correct source code files are not displayed. In the <em>Call Stack</em> window, double-click the topmost stack frame. A dialog titled 'Find Source: crashrpt.cpp' will appear. In this dialog, browse to the folder where you saved the source code and pick the <em>crashrpt.cpp</em> file. Now the correct source file should be displayed in Visual Studio source code window.<p>
At this point, you should be able to read the minidump correctly. If the problem remains, follow the instructions below:<p>
<ul>
<li>Ensure that correct matching binaries and/or PDB files were saved after compilation. Ensure you save excatly the same binaries and PDB files that were generated during the compilation/linking process. If you rebuild (or partially rebuild) your solution, you should save those files again.</li></ul>
<p>
<ul>
<li>If symbols for some modules of your program are loaded, and you are still unable to read the stack trace, than there were no debugging symbols generated for the module where crash had occurred. Check that you set Program Database (/Zi) compiler flag and Generate Debug Info (/DEBUG) linker flag for all modules of your application. For additional info, see <a class="el" href="configuring_project.html#prgdb">Enabling Program Database (/Zi, /DEBUG) in Release Configuration</a>.</li></ul>
<p>
<ul>
<li>If the stack trace is not as accurate as you expect, the reason may be the code optimizations. It is recommended that you turn the frame pointer omission (FPO) optimizations off.</li></ul>
<h2><a class="anchor" name="opening_minidump_in_windbg">
Opening Minidump in WinDbg</a></h2>
You can use <b>WinDbg</b> program from <b>Microsoft Debugging Tools for Windows</b> for opening crash minidumps. It is freely distributed.<p>
To open the minidump file, launch WinDbg and open the crash dump by pressing <em>CTRL+D</em> key combination. In the appeared Open File dialog, pick the <em>crashdump.dmp</em> and press the Open button. The <em>Command</em> window appears (see the figure below) allowing you to enter commands and see the output.<p>
<div align="center">
<img src="dbghelp_open_minidump.png" alt="dbghelp_open_minidump.png">
<p><strong>Opening a crash minidump in WinDbg</strong></p></div>
 Next, you need to set the symbol path for WinDbg with the <code></code>.sympath command. Switch to the command window (ALT+1) and enter <code></code>.sympath followed by a space followed by the semi-colon delimited list of directories to search.<p>
<div class="fragment"><pre class="fragment">.sympath D:\Projects\symbols\WTLDemo\1.4.1
</pre></div><p>
Similarly you need to set the executable and source search paths with the .exepath and <code></code>.srcpath commands.<p>
<div class="fragment"><pre class="fragment">.exepath D:\Projects\symbols\WTLDemo\1.4.1
.srcpath D:\Projects\WTLDemo
</pre></div><p>
The final step is to change the debugger context to the context record associated with the exception by entering the <code></code>.ecxr command.<p>
<div class="fragment"><pre class="fragment">.ecxr
</pre></div><p>
If everything is configured correctly, you should now be able to walk the call stack, see local variables, and loaded modules. You can even have WinDbg highlight the offending line of code by double clicking the WTLDemo frame in the Call Stack window (ALT+6). Note: The exact line number may be a little off due to linker optimizations.<p>
<em>Further reading:</em> <a class="el" href="automating_crash_report_processing.html">Automating Crash Report Processing</a>. </div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Mon Apr 8 15:41:10 2013 for CrashRpt by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9</small></address>
</body>
</html>

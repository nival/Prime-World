<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CrashRpt: Making Your Code Robust</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="style.css" rel="stylesheet" type="text/css">
<link rel="icon" href="../favicon.ico" type="image/x-icon" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
</head>
<body onload='searchBox.OnSelectItem(0);'>

<div style="padding:10px">
<table border="0" bgcolor="#FFFFFF" cellspacing="5" width="100%">
 <tr>
  <td width="24px" rowspan="2"><img src="../logo.png" alt="Logo" /></td>
  <td><font family="Arial" size="+2">crashrpt</font></td>
  <td rowspan="2" align="right"></td>
 </tr>
 <tr>
  <td colspan="2"><span style="font-size:0.9em"><i>A crash reporting system for Windows applications</i></a></td>
 </tr>
</table>
</div>


<!-- Generated by Doxygen 1.5.9 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Contents</span></a></li>
      <li><a href="modules.html"><span>API&nbsp;Reference</span></a></li>
      <li><a href="files.html"><span>File&nbsp;Reference</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">CrashRpt Documentation</a>&nbsp;&raquo&nbsp;<a class="el" href="other_topics.html">Other Topics</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="writing_robust_code">Making Your Code Robust </a></h1>This page contains some tips on writing C++ code robust to errors. A program that conforms to these rules is less likely to crash.<p>
This page contains the following topics:<p>
<ul>
<li><a class="el" href="writing_robust_code.html#coding_guide_intro">Introduction</a></li><li><a class="el" href="writing_robust_code.html#init_vars">Initializing Local Variables</a></li><li><a class="el" href="writing_robust_code.html#init_winapi_structures">Initializing WinAPI Structures</a></li><li><a class="el" href="writing_robust_code.html#validate_input">Validating Function Input</a></li><li><a class="el" href="writing_robust_code.html#validate_pointers">Validating Pointers</a></li><li><a class="el" href="writing_robust_code.html#init_func_output">Initializing Function Output</a></li><li><a class="el" href="writing_robust_code.html#clean_up_pointers">Cleaning Up Pointers to Deleted Objects</a></li><li><a class="el" href="writing_robust_code.html#clean_up_handles">Cleaning Up Released Handles</a></li><li><a class="el" href="writing_robust_code.html#delete_operator">Using delete [] Operator for Arrays</a></li><li><a class="el" href="writing_robust_code.html#allocate_memory_carefully">Allocating Memory Carefully</a></li><li><a class="el" href="writing_robust_code.html#use_asserts_carefully">Using Asserts Carefully</a></li><li><a class="el" href="writing_robust_code.html#check_return_code">Checking Return Code of a Function</a></li><li><a class="el" href="writing_robust_code.html#use_smart_ptrs">Using Smart Pointers</a></li><li><a class="el" href="writing_robust_code.html#equality_operator">Using == Operator Carefully</a></li></ul>
<h2><a class="anchor" name="coding_guide_intro">
Introduction</a></h2>
As a program grows in size and dependencies, you start losing trace of its components, get further away from the big picture, and ease the introduction of bugs [<a href="http://www.iovene.com/28/">How to write robust code</a>]. So it is important to realise that some rules should be followed to write a code more tolerant to errors.<p>
Generally speaking, robust code has such features as: it is well designed, neat and tidy, well named, well commented, well tested, it rarely crashes.<p>
If your program follows consistent coding rules (for example, <a href="http://geosoft.no/development/cppstyle.html">C++ Programming Style Guidelines</a>, <a href="http://www.doc.ic.ac.uk/lab/cplus/c%2b%2b.rules/chap4.html#sect2">Programming in C++, Rules and Recommendations</a> or <a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">Google C++ Style Guide</a>) it is less likely to crash, because it has a consistent structure.<p>
Even if your program currently doesn't follow any coding rules because of its complexity and because of your team structure, following the simple rules listed below may help you to avoid the majority of the crash situations.<h2><a class="anchor" name="init_vars">
Initializing Local Variables</a></h2>
Not ininitialized local variables are a common reason of program crashes. For example, see the following code fragment:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Define local variables</span>

  BOOL bExitResult; <span class="comment">// This will be TRUE if the function exits successfully</span>
  FILE* f; <span class="comment">// Handle to file</span>
  TCHAR szBuffer[_MAX_PATH];   <span class="comment">// String buffer</span>
    
  <span class="comment">// Do something with variables above...</span>
</pre></div><p>
The code fragment above can be a potential reason of a crash, because none of local variables is initialized. The correct code would be the following:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Define local variables</span>
  
  <span class="comment">// Initialize function exit code with FALSE to indicate failure assumption</span>
  BOOL bExitResult = FALSE; <span class="comment">// This will be TRUE if the function exits successfully</span>

  <span class="comment">// Initialize file handle with NULL</span>
  FILE* f = NULL; <span class="comment">// Handle to file</span>

  <span class="comment">// Initialize string buffer with empty string</span>
  TCHAR szBuffer[_MAX_PATH] = _T(<span class="stringliteral">""</span>);   <span class="comment">// String buffer</span>

  <span class="comment">// Do something with variables above...</span>
</pre></div><h2><a class="anchor" name="init_winapi_structures">
Initializing WinAPI Structures</a></h2>
Many WinAPI functions receive/return parameters through C structures. Such a structure, if incorrectly initialized, may be the reason of a crash.<p>
It is recommended to use <b>ZeroMemory()</b> or <b>memset()</b> to fill the structure with zeroes (this typically sets structure fields to their default values).<p>
Many WinAPI structures also have the <b>cbSize</b> parameter that must be initialized with the size of the structure before using.<p>
The following code shows how to initialize a WinAPI structure:<p>
<div class="fragment"><pre class="fragment">  NOTIFYICONDATA nf;
  memset(&amp;nf,0,<span class="keyword">sizeof</span>(NOTIFYICONDATA)); <span class="comment">// Zero memory</span>
  nf.cbSize = <span class="keyword">sizeof</span>(NOTIFYICONDATA); <span class="comment">// Set structure size!</span>
  <span class="comment">// Initialize other structure members</span>
  nf.hWnd = hWndParent;
  nf.uID = 0;   
  nf.uFlags = NIF_ICON | NIF_TIP;
  nf.hIcon = ::LoadIcon(NULL, IDI_APPLICATION);
  _tcscpy_s(nf.szTip, 128, _T(<span class="stringliteral">"Popup Tip Text"</span>));
        
  <span class="comment">// Add a tray icon</span>
  Shell_NotifyIcon(NIM_ADD, &amp;nf);
</pre></div><p>
But! DO NOT use <b>ZeroMemory()</b> or <b>memset()</b> for your C++ structures that contain objects as structure members, that may corrupt their internal state and be the reason of a crash.<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Declare a C++ structure</span>
  <span class="keyword">struct </span>ItemInfo
  {
    std::string sItemName; <span class="comment">// The structure has std::string object inside</span>
    <span class="keywordtype">int</span> nItemValue;
  };

  <span class="comment">// Init the structure</span>
  ItemInfo item;

  <span class="comment">// Do not use memset()! It can corrupt the structure</span>
  <span class="comment">// memset(&amp;item, 0, sizeof(ItemInfo));</span>

  <span class="comment">// Instead use the following</span>
  item.sItemName = <span class="stringliteral">"item1"</span>;
  item.nItemValue = 0;          
</pre></div><p>
It is even better to use a constructor for your C++ structure that would init its members with default values:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Declare a C++ structure</span>
  <span class="keyword">struct </span>ItemInfo
  {
    <span class="comment">// Use structure constructor to set members with default values</span>
    ItemInfo()
    {
      sItemName = _T(<span class="stringliteral">"unknown"</span>);
      nItemValue = -1;
    }
        
    std::string sItemName; <span class="comment">// The structure has std::string object inside</span>
    <span class="keywordtype">int</span> nItemValue;
  };

  <span class="comment">// Init the structure</span>
  ItemInfo item;

  <span class="comment">// Do not use memset()! It can corrupt the structure</span>
  <span class="comment">// memset(&amp;item, 0, sizeof(ItemInfo));</span>

  <span class="comment">// Instead use the following</span>
  item.sItemName = <span class="stringliteral">"item1"</span>;
  item.nItemValue = 0;          
</pre></div><h2><a class="anchor" name="validate_input">
Validating Function Input</a></h2>
It is recommended to always validate function input parameters.<p>
<div class="fragment"><pre class="fragment">  BOOL DrawVehicle(HWND hWnd, LPRECT prcDraw, <span class="keywordtype">int</span> nDrawingQuality)
  {
    <span class="comment">// Check that window is valid</span>
    <span class="keywordflow">if</span>(!IsWindow(hWnd))
      <span class="keywordflow">return</span> FALSE;

    <span class="comment">// Check that drawing rect is valid</span>
    <span class="keywordflow">if</span>(prcDraw==NULL)
      <span class="keywordflow">return</span> FALSE;

    <span class="comment">// Check drawing quality is valid</span>
    <span class="keywordflow">if</span>(nDrawingQuality&lt;0 || nDrawingQuality&gt;100)
      <span class="keywordflow">return</span> FALSE;
   
    <span class="comment">// Now it's safe to draw the vehicle</span>

    <span class="keywordflow">return</span> TRUE;
  }
</pre></div><h2><a class="anchor" name="validate_pointers">
Validating Pointers</a></h2>
If you use a pointer, make sure it is not equal to NULL.<p>
<div class="fragment"><pre class="fragment">  CVehicle* pVehicle = GetCurrentVehicle();
  
  <span class="comment">// Validate pointer</span>
  <span class="keywordflow">if</span>(pVehicle==NULL)
  {
    <span class="comment">// Invalid pointer, do not use it!</span>
    <span class="keywordflow">return</span> FALSE;
  }

  <span class="comment">// Use the pointer</span>
</pre></div><h2><a class="anchor" name="init_func_output">
Initializing Function Output</a></h2>
If your function creates an object and returns it as a function parameter, it is recommended to initialize the pointer with NULL in the beginning of the function body.<p>
If you do not explicitly initialize the output parameter and further it is not set due to a bug in function logics, the caller may use invalid pointer which would possibly cause a crash.<p>
Example of incorrect code:<p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> CreateVehicle(CVehicle** ppVehicle)
  {
    <span class="keywordflow">if</span>(CanCreateVehicle())
    {
      *ppVehicle = <span class="keyword">new</span> CVehicle();
      <span class="keywordflow">return</span> 1;
    }    

    <span class="comment">// If CanCreateVehicle() returns FALSE,</span>
    <span class="comment">// the pointer to *ppVehcile would never be set!</span>

    <span class="keywordflow">return</span> 0;
  }
</pre></div><p>
The correct code:<p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> CreateVehicle(CVehicle** ppVehicle)
  {
    <span class="comment">// First initialize the output parameter with NULL</span>
    *ppVehicle = NULL;

    <span class="keywordflow">if</span>(CanCreateVehicle())
    {
      *ppVehicle = <span class="keyword">new</span> CVehicle();
      <span class="keywordflow">return</span> 1;
    }    

    <span class="keywordflow">return</span> 0;
  }
</pre></div><h2><a class="anchor" name="clean_up_pointers">
Cleaning Up Pointers to Deleted Objects</a></h2>
Assign NULL to a pointer after freeing (or deleting) it. This will help to ensure noone will try to reuse an invalid pointer.<p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Create object</span>
 CVehicle* pVehicle = <span class="keyword">new</span> CVehicle();
 
 <span class="keyword">delete</span> pVehicle; <span class="comment">// Free pointer</span>
 pVehicle = NULL; <span class="comment">// Set pointer with NULL</span>
</pre></div><h2><a class="anchor" name="clean_up_handles">
Cleaning Up Released Handles</a></h2>
Assign NULL (or zero, or something else default value) to a handle after freeing it. This will help to ensure noone will try to reuse an invalid handle.<p>
Below is an example of how to clean up a WinAPI file handle. <div class="fragment"><pre class="fragment">  HANDLE hFile = INVALID_HANDLE_VALUE; 
  
  <span class="comment">// Open file</span>
  hFile = CreateFile(_T(<span class="stringliteral">"example.dat"</span>), FILE_READ|FILE_WRITE, FILE_OPEN_EXISTING);
  <span class="keywordflow">if</span>(hFile==INVALID_HANDLE_VALUE)
  {
    <span class="keywordflow">return</span> FALSE; <span class="comment">// Error opening file</span>
  }

  <span class="comment">// Do something with file</span>

  <span class="comment">// Finally, close the handle</span>
  <span class="keywordflow">if</span>(hFile!=INVALID_HANDLE_VALUE)
  {
    CloseHandle(hFile);   <span class="comment">// Close handle to file</span>
    hFile = INVALID_HANDLE_VALUE;   <span class="comment">// Clean up handle</span>
  }
</pre></div><p>
Below is an example of how to clean up a FILE* handle. <div class="fragment"><pre class="fragment">  <span class="comment">// First init file handle pointer with NULL</span>
  FILE* f = NULL;

  <span class="comment">// Open handle to file</span>
  errno_t err = _tfopen_s(_T(<span class="stringliteral">"example.dat"</span>), _T(<span class="stringliteral">"rb"</span>));
  <span class="keywordflow">if</span>(err!=0 || f==NULL)
    <span class="keywordflow">return</span> FALSE; <span class="comment">// Error opening file</span>

  <span class="comment">// Do something with file</span>

  <span class="comment">// When finished, close the handle</span>
  <span class="keywordflow">if</span>(f!=NULL) <span class="comment">// Check that handle is valid</span>
  {
    fclose(f);
    f = NULL; <span class="comment">// Clean up pointer to handle</span>
  }
</pre></div><h2><a class="anchor" name="delete_operator">
Using delete [] Operator for Arrays</a></h2>
If you allocate a single object with the operator <b>new</b>, you should free it with the operator <b>delete</b>.<p>
But if you allocate an array of objects with the operator <b>new</b>, you should free this array with <b> delete [] </b>.<p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Create an array of objects</span>
 CVehicle* paVehicles = <span class="keyword">new</span> CVehicle[10];
 
 <span class="keyword">delete</span> [] paVehicles; <span class="comment">// Free pointer to array</span>
 paVehicles = NULL; <span class="comment">// Set pointer with NULL</span>
</pre></div><p>
or<p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Create a buffer of bytes</span>
 LPBYTE pBuffer = <span class="keyword">new</span> BYTE[255];
 
 <span class="keyword">delete</span> [] pBuffer; <span class="comment">// Free pointer to array</span>
 pBuffer = NULL; <span class="comment">// Set pointer with NULL</span>
</pre></div><h2><a class="anchor" name="allocate_memory_carefully">
Allocating Memory Carefully</a></h2>
Ensure that 0 (zero) bytes are not allocated using <b>malloc()</b> or <b>new</b>.<p>
<div class="fragment"><pre class="fragment">  UINT uBufferSize = GetBufferSize(); <span class="comment">// Determine what buffer to allocate.</span>

  LPBYTE* pBuffer = NULL; <span class="comment">// Init pointer to buffer</span>

  <span class="comment">// Allocate a buffer only if buffer size &gt; 0</span>
  <span class="keywordflow">if</span>(uBufferSize!=0)
   pBuffer = <span class="keyword">new</span> BYTE[uBufferSize];
</pre></div><p>
For additional tips on how to allocate memory correctly, you can read the <a href="http://www.codeproject.com/KB/tips/CBP_for_memory_allocation.aspx">Secure Coding Best Practices for Memory Allocation in C and C++</a> article.<h2><a class="anchor" name="use_asserts_carefully">
Using Asserts Carefully</a></h2>
Asserts can be used in debug mode for checking preconditions and postconditions. But when you compile your program in release mode, asserts are removed on the preprocessing stage. So, using asserts is not enough to validate your program's state.<p>
Incorrect code:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;assert.h&gt;</span>
  
  CVehicle* ReadVehicleModelFromFile(LPCTSTR szFileName)
  {
    CVehicle* pVehicle = NULL; <span class="comment">// Pointer to vehicle object</span>

    <span class="comment">// Check preconditions</span>
    assert(szFileName!=NULL); <span class="comment">// This will be removed by preprocessor in Release mode!</span>
    assert(_tcslen(szFileName)!=0); <span class="comment">// This will be removed by preprocessor in Release mode!</span>

    <span class="comment">// Open the file</span>
    FILE* f = _tfopen(szFileName, _T(<span class="stringliteral">"rt"</span>));

    <span class="comment">// Create new CVehicle object</span>
    pVehicle = <span class="keyword">new</span> CVehicle();

    <span class="comment">// Read vehicle model from file</span>

    <span class="comment">// Check postcondition </span>
    assert(pVehicle-&gt;GetWheelCount()==4); <span class="comment">// This will be removed by preprocessor in Release mode!</span>

    <span class="comment">// Return pointer to the vehicle object</span>
    <span class="keywordflow">return</span> pVehicle;
  }
</pre></div><p>
As you can see in the code above, usage of asserts can help you to check your program state in Debug mode, but in Release mode these checks will just disappear.<p>
The correct code would be:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;assert.h&gt;</span>
  
  CVehicle* ReadVehicleModelFromFile(LPCTSTR szFileName, )
  {
    CVehicle* pVehicle = NULL; <span class="comment">// Pointer to vehicle object</span>

    <span class="comment">// Check preconditions</span>
    assert(szFileName!=NULL); <span class="comment">// This will be removed by preprocessor in Release mode!</span>
    assert(_tcslen(szFileName)!=0); <span class="comment">// This will be removed by preprocessor in Release mode!</span>

    <span class="keywordflow">if</span>(szFileName==NULL || _tcslen(szFileName)==0)
      <span class="keywordflow">return</span> NULL; <span class="comment">// Invalid input parameter</span>

    <span class="comment">// Open the file</span>
    FILE* f = _tfopen(szFileName, _T(<span class="stringliteral">"rt"</span>));

    <span class="comment">// Create new CVehicle object</span>
    pVehicle = <span class="keyword">new</span> CVehicle();

    <span class="comment">// Read vehicle model from file</span>

    <span class="comment">// Check postcondition </span>
    assert(pVehicle-&gt;GetWheelCount()==4); <span class="comment">// This will be removed by preprocessor in Release mode!</span>

    <span class="keywordflow">if</span>(pVehicle-&gt;GetWheelCount!=4)
    { 
      <span class="comment">// Oops... an invalid wheel count was encountered!  </span>
      <span class="keyword">delete</span> pVehicle; 
      pVehicle = NULL;
    }

    <span class="comment">// Return pointer to the vehicle object</span>
    <span class="keywordflow">return</span> pVehicle;
  }
</pre></div><h2><a class="anchor" name="check_return_code">
Checking Return Code of a Function</a></h2>
It is a common mistake to call the function and assume it will succeed. When you call a function, it is recommended to check its return code and values of output parameters.<p>
The following code calls functions in succession. Whether to proceed or to exit depends on return code and output parameters.<p>
<div class="fragment"><pre class="fragment">    HRESULT hres = E_FAIL;
    IWbemServices *pSvc = NULL;
    IWbemLocator *pLoc = NULL;
    
    hres =  CoInitializeSecurity(
        NULL, 
        -1,                          <span class="comment">// COM authentication</span>
        NULL,                        <span class="comment">// Authentication services</span>
        NULL,                        <span class="comment">// Reserved</span>
        RPC_C_AUTHN_LEVEL_DEFAULT,   <span class="comment">// Default authentication </span>
        RPC_C_IMP_LEVEL_IMPERSONATE, <span class="comment">// Default Impersonation  </span>
        NULL,                        <span class="comment">// Authentication info</span>
        EOAC_NONE,                   <span class="comment">// Additional capabilities </span>
        NULL                         <span class="comment">// Reserved</span>
        );

                      
    <span class="keywordflow">if</span> (FAILED(hres))
    {
        log_write(_T(<span class="stringliteral">"Failed to initialize security. Error code = %X\n"</span>), hres);
        <span class="keywordflow">if</span>(hres!=RPC_E_TOO_LATE) <span class="keywordflow">return</span> FALSE;
    }
    
    hres = CoCreateInstance(
        CLSID_WbemLocator,             
        0, 
        CLSCTX_INPROC_SERVER, 
        IID_IWbemLocator, (LPVOID *) &amp;pLoc);
 
    <span class="keywordflow">if</span> (FAILED(hres) || !pLoc)
    {
        log_write(_T(<span class="stringliteral">"Failed to create IWbemLocator object. Err code = %X"</span>), hres);
        <span class="keywordflow">return</span> FALSE;               
    }
   
    hres = pLoc-&gt;ConnectServer(
         _bstr_t(L<span class="stringliteral">"ROOT\\CIMV2"</span>), <span class="comment">// Object path of WMI namespace</span>
         NULL,                    <span class="comment">// User name. NULL = current user</span>
         NULL,                    <span class="comment">// User password. NULL = current</span>
         0,                       <span class="comment">// Locale. NULL indicates current</span>
         NULL,                    <span class="comment">// Security flags.</span>
         0,                       <span class="comment">// Authority (e.g. Kerberos)</span>
         0,                       <span class="comment">// Context object </span>
         &amp;pSvc                    <span class="comment">// pointer to IWbemServices proxy</span>
         );
    
    <span class="keywordflow">if</span> (FAILED(hres) || !pSvc)
    {
        log_write(_T(<span class="stringliteral">"Couldn't conect server\n"</span>));      
        <span class="keywordflow">if</span>(pLoc) pLoc-&gt;Release();     
        <span class="keywordflow">return</span> FALSE;  
    }

    hres = CoSetProxyBlanket(
       pSvc,                        <span class="comment">// Indicates the proxy to set</span>
       RPC_C_AUTHN_WINNT,           <span class="comment">// RPC_C_AUTHN_xxx</span>
       RPC_C_AUTHZ_NONE,            <span class="comment">// RPC_C_AUTHZ_xxx</span>
       NULL,                        <span class="comment">// Server principal name </span>
       RPC_C_AUTHN_LEVEL_CALL,      <span class="comment">// RPC_C_AUTHN_LEVEL_xxx </span>
       RPC_C_IMP_LEVEL_IMPERSONATE, <span class="comment">// RPC_C_IMP_LEVEL_xxx</span>
       NULL,                        <span class="comment">// client identity</span>
       EOAC_NONE                    <span class="comment">// proxy capabilities </span>
    );

    <span class="keywordflow">if</span> (FAILED(hres))
    {
        log_write(_T(<span class="stringliteral">"Could not set proxy blanket.\n"</span>));
        <span class="keywordflow">if</span>(pSvc) pSvc-&gt;Release();
        <span class="keywordflow">if</span>(pLoc) pLoc-&gt;Release();     
        <span class="keywordflow">return</span> FALSE;               
    }
</pre></div><h2><a class="anchor" name="use_smart_ptrs">
Using Smart Pointers</a></h2>
If you intensively use pointers to shared objects (e.g., COM interfaces), it is a good practice to wrap them into smart pointers. The smart pointer will take care of your object's reference counting and will protect you from accessing an object that was already deleted. That is, you don't need to worry about controlling the lifetime of your interface pointer.<p>
For additional info on smart pointers, see the following articles: <a href="http://ootips.org/yonat/4dev/smart-pointers.html">Smart Pointers - What, Why, Which?</a> and <a href="http://www.codeproject.com/KB/cpp/SmartPointers.aspx">Implementing a Simple Smart Pointer in C++</a>.<p>
Below is an example code (borrowed from MSDN) that uses ATL's <a href="http://msdn.microsoft.com/en-us/library/ezzw7k98(v=VS.100).aspx"><b>CComPtr</b></a> template class as a smart pointer.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;windows.h&gt;</span>
<span class="preprocessor">#include &lt;shobjidl.h&gt;</span> 
<span class="preprocessor">#include &lt;atlbase.h&gt;</span> <span class="comment">// Contains the declaration of CComPtr.</span>

<span class="keywordtype">int</span> WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR pCmdLine, <span class="keywordtype">int</span> nCmdShow)
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | 
        COINIT_DISABLE_OLE1DDE);
    <span class="keywordflow">if</span> (SUCCEEDED(hr))
    {
        CComPtr&lt;IFileOpenDialog&gt; pFileOpen;

        <span class="comment">// Create the FileOpenDialog object.</span>
        hr = pFileOpen.CoCreateInstance(__uuidof(FileOpenDialog));
        <span class="keywordflow">if</span> (SUCCEEDED(hr))
        {
            <span class="comment">// Show the Open dialog box.</span>
            hr = pFileOpen-&gt;Show(NULL);

            <span class="comment">// Get the file name from the dialog box.</span>
            <span class="keywordflow">if</span> (SUCCEEDED(hr))
            {
                CComPtr&lt;IShellItem&gt; pItem;
                hr = pFileOpen-&gt;GetResult(&amp;pItem);
                <span class="keywordflow">if</span> (SUCCEEDED(hr))
                {
                    PWSTR pszFilePath;
                    hr = pItem-&gt;GetDisplayName(SIGDN_FILESYSPATH, &amp;pszFilePath);

                    <span class="comment">// Display the file name to the user.</span>
                    <span class="keywordflow">if</span> (SUCCEEDED(hr))
                    {
                        MessageBox(NULL, pszFilePath, L<span class="stringliteral">"File Path"</span>, MB_OK);
                        CoTaskMemFree(pszFilePath);
                    }
                }

                <span class="comment">// pItem goes out of scope.</span>
            }

            <span class="comment">// pFileOpen goes out of scope.</span>
        }
        CoUninitialize();
    }
    <span class="keywordflow">return</span> 0;
} 
</pre></div><h2><a class="anchor" name="equality_operator">
Using == Operator Carefully</a></h2>
Look at the following code fragment:<p>
<div class="fragment"><pre class="fragment">  CVehicle* pVehicle = GetCurrentVehicle();

  <span class="comment">// Validate pointer</span>
  <span class="keywordflow">if</span>(pVehicle==NULL) <span class="comment">// Using == operator to compare pointer with NULL</span>
     <span class="keywordflow">return</span> FALSE; 

  <span class="comment">// Do something with the pointer</span>
  pVehicle-&gt;Run();
</pre></div><p>
The code above is correct and uses pointer validation. But, assume you made a mistyping and used an assignment operator (=) instead of equality operator (==):<p>
<div class="fragment"><pre class="fragment">  CVehicle* pVehicle = GetCurrentVehicle();

  <span class="comment">// Validate pointer</span>
  <span class="keywordflow">if</span>(pVehicle=NULL) <span class="comment">// Oop! A mistyping here!</span>
     <span class="keywordflow">return</span> FALSE; 

  <span class="comment">// Do something with the pointer</span>
  pVehicle-&gt;Run(); <span class="comment">// Crash!!! </span>
</pre></div><p>
As you can see from the code above, such mistyping may be the result of a stupid crash.<p>
Such error can be avoided by slightly modifying the pointer validation code (exchange left side and right side of the equality operator). If you mistype in such modifyed code, such mistyping will be detected on compilation stage.<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Validate pointer</span>
  <span class="keywordflow">if</span>(NULL==pVehicle) <span class="comment">// Exchange left side and right side of the equality operator</span>
     <span class="keywordflow">return</span> FALSE; 

  <span class="comment">// Validate pointer</span>
  <span class="keywordflow">if</span>(NULL=pVehicle) <span class="comment">// Oop! A mistyping here! But the compiler returns an error message.</span>
     <span class="keywordflow">return</span> FALSE; 
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Mon Apr 8 15:41:10 2013 for CrashRpt by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9</small></address>
</body>
</html>
